// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://qzwxisdfwswsrbzvpzlo.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InF6d3hpc2Rmd3N3c3JienZwemxvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzg1OTg2NjYsImV4cCI6MjA1NDE3NDY2Nn0.nVV1d-_BfhfVNOSiusg8zSuvPwS4dSB-cJAMGVjujr4";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// =============================================================================
// PRODUCTION HOST DETECTION
// Canonical helper: treats buntinggpt.com, www.buntinggpt.com, and all
// *.buntinggpt.com subdomains as production hosts.
// =============================================================================
export const isProductionHost = (hostname: string): boolean => {
  return hostname === 'buntinggpt.com' || 
         hostname === 'www.buntinggpt.com' || 
         hostname.endsWith('.buntinggpt.com');
};

// Check if we're on the production domain
const isProductionDomain = typeof window !== 'undefined' && isProductionHost(window.location.hostname);

// Log storage mode for debugging
if (typeof window !== 'undefined') {
  console.log('Supabase auth storage mode:', isProductionDomain ? 'cookie (production)' : 'localStorage (dev)');
}

// Cookie configuration matching gate.buntinggpt.com specification
const COOKIE_NAME = 'bunting-auth-token';
const CHUNK_THRESHOLD = 3800; // Split if session > 3800 bytes
const CHUNK_SIZE = 3800;
const MAX_AGE = 31536000; // 1 year

// Custom cookie storage following gate.buntinggpt.com chunking protocol:
// - Small session (< 3800 bytes): Single `bunting-auth-token` cookie
// - Large session (> 3800 bytes): Split into `bunting-auth-token.0`, `.1`, etc. + `.count`
const cookieStorage = {
  getItem: (key: string): string | null => {
    try {
      const cookies = document.cookie.split('; ').reduce((acc, cookie) => {
        const [k, ...v] = cookie.split('=');
        acc[k] = v.join('=');
        return acc;
      }, {} as Record<string, string>);

      // Check for chunked storage first (has .count cookie)
      const countCookie = cookies[`${COOKIE_NAME}.count`];
      if (countCookie) {
        const count = parseInt(countCookie, 10);
        if (!isNaN(count) && count > 0) {
          const chunks: string[] = [];
          for (let i = 0; i < count; i++) {
            const chunk = cookies[`${COOKIE_NAME}.${i}`];
            if (chunk) {
              chunks.push(chunk);
            } else {
              console.warn(`Missing chunk ${i} of ${count}`);
              return null;
            }
          }
          const encoded = chunks.join('');
          const decoded = decodeURIComponent(encoded);
          console.log(`Cookie read [${key}]: reassembled ${count} chunks (${decoded.length} chars)`);
          return decoded || null;
        }
      }

      // Fall back to single cookie
      const single = cookies[COOKIE_NAME];
      if (single) {
        const decoded = decodeURIComponent(single);
        console.log(`Cookie read [${key}]: single cookie (${decoded.length} chars)`);
        return decoded || null;
      }

      console.log(`Cookie read [${key}]: not found`);
      return null;
    } catch (e) {
      console.error('Cookie read error:', e);
      return null;
    }
  },

  setItem: (key: string, value: string): void => {
    try {
      // First, clear any existing cookies
      cookieStorage.removeItem(key);

      const encoded = encodeURIComponent(value);
      const cookieOptions = `path=/; domain=.buntinggpt.com; max-age=${MAX_AGE}; SameSite=Lax; Secure`;

      if (encoded.length <= CHUNK_THRESHOLD) {
        // Small session: single cookie
        document.cookie = `${COOKIE_NAME}=${encoded}; ${cookieOptions}`;
        console.log(`Cookie set [${key}]: single cookie (${value.length} chars)`);
      } else {
        // Large session: split into chunks
        const chunks: string[] = [];
        for (let i = 0; i < encoded.length; i += CHUNK_SIZE) {
          chunks.push(encoded.substring(i, i + CHUNK_SIZE));
        }

        // Write each chunk
        chunks.forEach((chunk, index) => {
          document.cookie = `${COOKIE_NAME}.${index}=${chunk}; ${cookieOptions}`;
        });

        // Write the count
        document.cookie = `${COOKIE_NAME}.count=${chunks.length}; ${cookieOptions}`;

        console.log(`Cookie set [${key}]: ${chunks.length} chunks (${value.length} chars)`);
      }
    } catch (e) {
      console.error('Cookie write error:', e);
    }
  },

  removeItem: (key: string): void => {
    try {
      const expireOptions = 'path=/; domain=.buntinggpt.com; max-age=0';
      let removed = 0;

      // Remove single cookie
      document.cookie = `${COOKIE_NAME}=; ${expireOptions}`;
      removed++;

      // Remove all possible chunks (check up to 20 chunks)
      for (let i = 0; i < 20; i++) {
        document.cookie = `${COOKIE_NAME}.${i}=; ${expireOptions}`;
        removed++;
      }

      // Remove count cookie
      document.cookie = `${COOKIE_NAME}.count=; ${expireOptions}`;
      removed++;

      console.log(`Cookie removed [${key}]: cleared all bunting-auth-token cookies`);
    } catch (e) {
      console.error('Cookie remove error:', e);
    }
  },
};

// Use localStorage for non-production environments (localhost, preview URLs)
const devStorage = typeof window !== 'undefined' ? window.localStorage : undefined;

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: isProductionDomain ? cookieStorage : devStorage,
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    flowType: 'pkce',
  }
});
