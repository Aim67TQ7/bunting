// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://qzwxisdfwswsrbzvpzlo.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InF6d3hpc2Rmd3N3c3JienZwemxvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzg1OTg2NjYsImV4cCI6MjA1NDE3NDY2Nn0.nVV1d-_BfhfVNOSiusg8zSuvPwS4dSB-cJAMGVjujr4";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Check if we're on the production domain
const isProductionDomain = typeof window !== 'undefined' && window.location.hostname.endsWith('.buntinggpt.com');

// Log storage mode for debugging
if (typeof window !== 'undefined') {
  console.log('Supabase auth storage mode:', isProductionDomain ? 'cookie (production)' : 'localStorage (dev)');
}

// Cookie chunk size (keep well under 4KB; attributes + key name add overhead)
// NOTE: values are URL-encoded, so size can inflate vs raw string.
const COOKIE_CHUNK_SIZE = 2500;

// Custom cookie storage that splits large values across multiple cookies
const cookieStorage = {
  getItem: (key: string): string | null => {
    try {
      const encodedKey = encodeURIComponent(key);
      const cookieArray = document.cookie.split(';');

      // First check if this is a chunked cookie
      const chunkCountCookie = cookieArray.find(c => c.trim().startsWith(`${encodedKey}_chunks=`));

      if (chunkCountCookie) {
        // Reassemble chunked cookie (IMPORTANT: concatenate encoded chunks, then decode once)
        const chunkCount = parseInt(chunkCountCookie.split('=')[1], 10);
        let encodedValue = '';

        for (let i = 0; i < chunkCount; i++) {
          const chunkKey = `${encodedKey}_${i}=`;
          const chunkCookie = cookieArray.find(c => c.trim().startsWith(chunkKey));
          if (chunkCookie) {
            const chunkPart = chunkCookie.trim().substring(chunkKey.length);
            encodedValue += chunkPart;
          } else {
            console.warn(`Cookie chunk ${i} not found for ${key}`);
            return null;
          }
        }

        const decodedValue = decodeURIComponent(encodedValue);
        console.log(`Cookie read [${key}]: found (${decodedValue.length} chars from ${chunkCount} chunks)`);
        return decodedValue || null;
      }

      // Try single cookie (for backward compatibility or small values)
      const singleKey = `${encodedKey}=`;
      for (let cookie of cookieArray) {
        cookie = cookie.trim();
        if (cookie.startsWith(singleKey)) {
          const value = cookie.substring(singleKey.length);
          const decodedValue = decodeURIComponent(value);
          console.log(`Cookie read [${key}]: found (${decodedValue.length} chars, single cookie)`);
          return decodedValue || null;
        }
      }

      console.log(`Cookie read [${key}]: not found`);
      return null;
    } catch (e) {
      console.error('Cookie read error:', e);
      return null;
    }
  },
  
  setItem: (key: string, value: string): void => {
    try {
      const maxAge = 60 * 60 * 24 * 7; // 7 days
      const encodedKey = encodeURIComponent(key);
      const cookieOptions = `path=/; domain=.buntinggpt.com; max-age=${maxAge}; SameSite=Lax; Secure`;

      // First, clear any existing chunks
      cookieStorage.removeItem(key);

      // Store URL-encoded value in cookie(s)
      const encodedValue = encodeURIComponent(value);

      // If the encoded value is small enough, use a single cookie
      if (encodedValue.length <= COOKIE_CHUNK_SIZE) {
        document.cookie = `${encodedKey}=${encodedValue}; ${cookieOptions}`;
        console.log(`Cookie set [${key}]: ${value.length} chars (single cookie)`);
        return;
      }

      // Split into chunks (chunks are already URL-encoded; do NOT decode per-chunk on read)
      const chunks: string[] = [];
      for (let i = 0; i < encodedValue.length; i += COOKIE_CHUNK_SIZE) {
        chunks.push(encodedValue.substring(i, i + COOKIE_CHUNK_SIZE));
      }

      // Store chunk count
      document.cookie = `${encodedKey}_chunks=${chunks.length}; ${cookieOptions}`;

      // Store each chunk
      chunks.forEach((chunk, index) => {
        document.cookie = `${encodedKey}_${index}=${chunk}; ${cookieOptions}`;
      });

      console.log(`Cookie set [${key}]: ${value.length} chars (${chunks.length} chunks)`);
    } catch (e) {
      console.error('Cookie write error:', e);
    }
  },
  
  removeItem: (key: string): void => {
    try {
      const encodedKey = encodeURIComponent(key);
      const expireOptions = `path=/; domain=.buntinggpt.com; expires=Thu, 01 Jan 1970 00:00:00 GMT; SameSite=Lax; Secure`;
      
      // Remove single cookie
      document.cookie = `${encodedKey}=; ${expireOptions}`;
      
      // Check for and remove chunked cookies
      const cookieArray = document.cookie.split(';');
      const chunkCountCookie = cookieArray.find(c => c.trim().startsWith(`${encodedKey}_chunks=`));
      
      if (chunkCountCookie) {
        const chunkCount = parseInt(chunkCountCookie.split('=')[1], 10);
        
        // Remove chunk count cookie
        document.cookie = `${encodedKey}_chunks=; ${expireOptions}`;
        
        // Remove all chunk cookies
        for (let i = 0; i < chunkCount; i++) {
          document.cookie = `${encodedKey}_${i}=; ${expireOptions}`;
        }
        
        console.log(`Cookie removed [${key}]: ${chunkCount} chunks`);
      } else {
        console.log(`Cookie removed [${key}]`);
      }
    } catch (e) {
      console.error('Cookie remove error:', e);
    }
  }
};

// Use localStorage for non-production environments
const devStorage = typeof window !== 'undefined' ? window.localStorage : undefined;

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: isProductionDomain ? cookieStorage : devStorage,
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    flowType: 'pkce',
  }
});